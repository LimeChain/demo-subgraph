type Gravatar @entity {
  id: ID!
  owner: Bytes!
  displayName: String!
  imageUrl: String!
}

type Transaction @entity {
  id: ID!
  displayName: String!
  imageUrl: String!
}

enum TraitType {
  TYPE
  ACCESSORY
}

enum EventType {
  ASSIGN
  TRANSFER
  ASK_CREATED
  ASK_REMOVED
  BID_CREATED
  BID_REMOVED
  SALE
  WRAP
  UNWRAP
}

enum OfferType {
  BID
  ASK
}

interface NFT {
  id: ID!
  contract: Contract
  tokenId: BigInt!
  owner: Account!
  events: [Event!]! @derivedFrom(field: "nft")
}

interface Event {
  id: ID!
  contract: Contract
  nft: NFT!
  blockNumber: BigInt!
  blockHhash: Bytes!
  txHash: Bytes!
  timestamp: BigInt!
  type: EventType!
  from: Account
  to: Account
  amount: BigInt
}

type Account @entity {
  "Ethereum Address"
  id: ID!

  "All Punks owned by Account"
  punksOwned: [Punk!] @derivedFrom(field: "owner")

  "Purchases by Account"
  bought: [Sale!]! @derivedFrom(field: "to")

  "All Punks owned by Account"
  nftsOwned: [NFT!]! @derivedFrom(field: "owner")

  "Punks assigned to account (if any)"
  assigned: [Assign!]! @derivedFrom(field: "to")

  "Punk transfer by Account"
  sent: [Transfer!]! @derivedFrom(field: "from")

  received: [Transfer!]! @derivedFrom(field: "to")

  "Query bids to Account or by Account"
  bids: [Bid!]! @derivedFrom(field: "from")

  "Punks offered for sale by Account"
  asks: [Ask!]! @derivedFrom(field: "from")

  numberOfPunksOwned: BigInt!
}

type Punk implements NFT @entity {
  "Punk"
  id: ID!
  transferedTo: Account
  assignedTo: Account
  purchasedBy: Account
  metadata: MetaData
  contract: Contract
  tokenId: BigInt!
  owner: Account!
  wrapped: Boolean!
  events: [Event!]! @derivedFrom(field: "nft")
}

type MetaData @entity {
  id: ID!
  tokenId: BigInt!
  tokenURI: String!
  imageURI: String!
  contractURI: String!
  punk: Punk!
  traits: [Trait!]
}

type Trait @entity {
  id: ID!
  type: TraitType!
  metaDatas: [MetaData!]! @derivedFrom(field: "traits")
  numberOfNfts: BigInt!
}

interface Offer {
  id: ID!
  from: Account!
  open: Boolean!
  amount: BigInt!
  nft: NFT!
  created: Event!
  removed: Event
  offerType: OfferType!
}

type Ask implements Offer @entity {
  id: ID!
  from: Account!
  open: Boolean!
  amount: BigInt!
  nft: NFT!
  created: Event!
  removed: Event
  offerType: OfferType!
}

type Bid implements Offer @entity {
  id: ID!
  from: Account!
  open: Boolean!
  amount: BigInt!
  nft: NFT!
  created: Event!
  removed: Event
  offerType: OfferType!
}

type Contract @entity {
  "Contract Address"
  id: ID!

  "Token Symbol"
  symbol: String

  "Token name"
  name: String

  "Total supply of tokens"
  totalSupply: BigInt!

  totalSales: BigInt!

  totalAmountTraded: BigInt!

  "The hash of the composite image of all the Punks"
  imageHash: String
}

type Assign implements Event @entity {
  id: ID!
  contract: Contract
  nft: NFT!
  blockNumber: BigInt!
  blockHhash: Bytes!
  txHash: Bytes!
  timestamp: BigInt!
  type: EventType!
  to: Account
  amount: BigInt
  from: Account
}

type Sale implements Event @entity {
  id: ID!
  to: Account
  amount: BigInt
  from: Account
  contract: Contract
  nft: NFT!
  blockNumber: BigInt!
  blockHhash: Bytes!
  txHash: Bytes!
  timestamp: BigInt!
  type: EventType!
}

type AskCreated implements Event @entity {
  id: ID!
  from: Account
  to: Account
  amount: BigInt
  contract: Contract
  nft: NFT!
  blockNumber: BigInt!
  blockHhash: Bytes!
  txHash: Bytes!
  timestamp: BigInt!
  type: EventType!
}

type BidCreated implements Event @entity {
  id: ID!
  from: Account
  to: Account
  amount: BigInt
  contract: Contract
  nft: NFT!
  blockNumber: BigInt!
  blockHhash: Bytes!
  txHash: Bytes!
  timestamp: BigInt!
  type: EventType!
}

type BidRemoved implements Event @entity {
  id: ID!
  from: Account
  to: Account
  amount: BigInt
  bid: BidCreated!
  contract: Contract
  nft: NFT!
  blockNumber: BigInt!
  blockHhash: Bytes!
  txHash: Bytes!
  timestamp: BigInt!
  type: EventType!
}

type AskRemoved implements Event @entity {
  id: ID!
  ask: AskCreated!
  from: Account
  to: Account
  amount: BigInt
  contract: Contract
  nft: NFT!
  blockNumber: BigInt!
  blockHhash: Bytes!
  txHash: Bytes!
  timestamp: BigInt!
  type: EventType!
}

type Transfer implements Event @entity {
  id: ID!
  from: Account
  to: Account
  amount: BigInt
  contract: Contract
  nft: NFT!
  blockNumber: BigInt!
  blockHhash: Bytes!
  txHash: Bytes!
  timestamp: BigInt!
  type: EventType!
}

type Wrap implements Event @entity {
  id: ID!
  from: Account
  to: Account
  amount: BigInt
  contract: Contract
  nft: NFT!
  blockNumber: BigInt!
  blockHhash: Bytes!
  txHash: Bytes!
  timestamp: BigInt!
  type: EventType!
}

type Unwrap implements Event @entity {
  id: ID!
  from: Account
  to: Account
  amount: BigInt
  contract: Contract
  nft: NFT!
  blockNumber: BigInt!
  blockHhash: Bytes!
  txHash: Bytes!
  timestamp: BigInt!
  type: EventType!
}

type BentoBox @entity {
  # Contract ID
  id: ID!

  users: [User!] @derivedFrom(field: "bentoBox")
  tokens: [Token!] @derivedFrom(field: "bentoBox")
  kashiPairs: [KashiPair!] @derivedFrom(field: "bentoBox")
  transactions: [BentoBoxAction!] @derivedFrom(field: "bentoBox")
  flashloans: [FlashLoan!] @derivedFrom(field: "bentoBox")
  masterContracts: [MasterContract!] @derivedFrom(field: "bentoBox")
  #protocols

  totalTokens: BigInt!
  totalKashiPairs: BigInt!
  totalUsers: BigInt!

  block: BigInt!
  timestamp: BigInt!
}

enum BentoBoxActionType {
  deposit
  transfer
  withdraw
}

type BentoBoxAction @entity {
  id: ID!
  bentoBox: BentoBox!
  type: BentoBoxActionType!
  from: User!
  to: User!
  token: Token!
  amount: BigInt!
  share: BigInt!
  block: BigInt!
  timestamp: BigInt!
}

type FlashLoan @entity {
  id: ID!
  bentoBox: BentoBox!
  borrower: Bytes!
  receiver: Bytes!
  token: Token!
  amount: BigInt!
  feeAmount: BigInt!
  block: BigInt!
  timestamp: BigInt!
}

type MasterContract @entity {
  id: ID!
  bentoBox: BentoBox!
  clones: [Clone!] @derivedFrom(field: "masterContract")
  masterContractApprovals: [MasterContractApproval!] @derivedFrom(field: "masterContract")
}

type Clone @entity {
  id: ID!
  bentoBox: BentoBox!
  masterContract: MasterContract!
  data: String!
  block: BigInt!
  timestamp: BigInt!
}

type MasterContractApproval @entity {
  # concatenate UserAddress with MasterContract
  id: ID!
  masterContract: MasterContract!
  user: User!
  approved: Boolean!
}

# TODO: Not sure what do with the Protocols that get registered
type Protocol @entity {
  id: ID!
}

type Token @entity {
  id: ID!
  bentoBox: BentoBox!
  name: String!
  symbol: String!
  decimals: BigInt!
  totalSupplyElastic: BigInt!
  totalSupplyBase: BigInt!
  strategy: Strategy
  strategyTargetPercentage: BigInt!
  block: BigInt!
  timestamp: BigInt!
}

type User @entity {
  id: ID!
  bentoBox: BentoBox!
  masterContractApprovals: [MasterContractApproval!] @derivedFrom(field: "user")
  tokens: [UserToken!] @derivedFrom(field: "user")
  kashiPairs: [UserKashiPair!] @derivedFrom(field: "user")
  withdrawals: [BentoBoxAction!] @derivedFrom(field: "from")
  deposits: [BentoBoxAction!] @derivedFrom(field: "to")
  block: BigInt!
  timestamp: BigInt!
}

type UserToken @entity {
  # concatenate UserAddress with TokenAddress
  id: ID!
  user: User!
  token: Token!
  share: BigInt!
  block: BigInt!
  timestamp: BigInt!
}

enum KashiPairType {
  medium
}

type KashiPair @entity {
  id: ID!
  bentoBox: BentoBox!
  type: KashiPairType!
  masterContract: MasterContract!
  owner: Bytes!
  feeTo: Bytes!
  name: String!
  symbol: String!
  oracle: Bytes!
  asset: Token!
  collateral: Token!
  exchangeRate: BigInt!
  totalAssetElastic: BigInt!
  totalAssetBase: BigInt!
  totalCollateralShare: BigInt!
  totalBorrowElastic: BigInt!
  totalBorrowBase: BigInt!
  interestPerSecond: BigInt!
  utilization: BigInt!
  feesEarnedFraction: BigInt!
  totalFeesEarnedFraction: BigInt!
  lastAccrued: BigInt!
  supplyAPR: BigInt!
  borrowAPR: BigInt!
  transactions: [KashiPairAction!] @derivedFrom(field: "pair")
  users: [UserKashiPair!] @derivedFrom(field: "pair")
  block: BigInt!
  timestamp: BigInt!
}

enum KashiPairActionType {
  addAsset
  removeAsset
  addCollateral
  removeCollateral
  borrow
  repay
}

type KashiPairAction @entity {
  id: ID!
  type: KashiPairActionType!
  pair: KashiPair!
  root: UserKashiPair!
  token: Token!
  amount: BigInt
  share: BigInt
  feeAmount: BigInt
  fraction: BigInt
  part: BigInt
  poolPercentage: BigInt!
  block: BigInt!
  timestamp: BigInt!
}

type UserKashiPair @entity {
  id: ID!
  user: User!
  pair: KashiPair!
  assetFraction: BigInt! #comes from balanceOf on pair contract
  collateralShare: BigInt!
  borrowPart: BigInt!
  transactions: [KashiPairAction!] @derivedFrom(field: "root")
  block: BigInt!
  timestamp: BigInt!
}

type KashiPairHourData @entity {
  # pair id - hour start timestamp
  id: ID!

  hourStartUnix: Int!

  pair: KashiPair!

  totalAssetElastic: BigInt!
  totalAssetBase: BigInt!
  totalCollateralShare: BigInt!
  totalBorrowElastic: BigInt!
  totalBorrowBase: BigInt!

  #hourlyVolumeSupplied
  #hourlyVolumeBorrowed
  #hourlyTxns

  #totalFeesEarnedFraction: BigInt!
  avgExchangeRate: BigInt!
  avgUtilization: BigInt!
  avgInterestPerSecond: BigInt!
  #avgSupplyInterestPerSecond: BigInt!
  #avgBorrowInterestPerSecond: BigInt!
}

type KashiPairDayData @entity {
  # pair id - day start timestamp
  id: ID!

  # date - hour start timestamp
  date: Int!

  pair: KashiPair!

  totalAssetElastic: BigInt!
  totalAssetBase: BigInt!
  totalCollateralShare: BigInt!
  totalBorrowElastic: BigInt!
  totalBorrowBase: BigInt!

  #hourlyVolumeSupplied
  #hourlyVolumeBorrowed
  #hourlyTxns

  #totalFeesEarnedFraction: BigInt!
  avgExchangeRate: BigInt!
  avgUtilization: BigInt!
  avgInterestPerSecond: BigInt!
  #avgSupplyInterestPerSecond: BigInt!
  #avgBorrowInterestPerSecond: BigInt!
}

type Strategy @entity {
  id: ID!
  token: Token!
  balance: BigInt!
  totalProfit: BigInt!
  harvests: [StrategyHarvest!] @derivedFrom(field: "strategy")
  timestamp: BigInt!
  block: BigInt!
}

type StrategyHarvest @entity {
  id: ID!
  strategy: Strategy!
  profit: BigInt!
  tokenElastic: BigInt!
  timestamp: BigInt!
  block: BigInt!
}
